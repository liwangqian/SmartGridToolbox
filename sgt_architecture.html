<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8' />
		<meta http-equiv="X-UA-Compatible" content="chrome=1" />
		<meta name="description" content="NICTA SmartGridToolbox : Microgrid tutorial" />
		<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
		<title>NICTA SmartGridToolbox Architecture</title>
	</head>
	<body>
	<!-- MAIN CONTENT -->
		<div id="main_content_wrap" class="outer">
			<section id="main_content" class="inner">
				<p>
					<img src="https://github.inside.nicta.com.au/dgordon/SmartGridToolbox/blob/master/images/logo.png?raw=true" alt="SmartGridToolbox Logo">
				</p>
				<h3><a name="sgt-architecture" class="anchor" href="#sgt-architecture"></a>Introduction to the SmartGridToolbox Architecture</h3>
				<p>
					SmartGridToolbox is a library that can be used to rapidly develop simulations of of smart grid and microgrid systems. It is written in C++-11, and users will need access to a compiler that can handle this C++ specification.
				</p>
				<h4><a name="sgt-library" class="anchor" href="#sgt-library"></a>Including and linking the SmartGridToolbox library</h4>
				<p>
					SmartGridToolbox programs will need to link to the SmartGridToolbox library, and will need to include the relevant SmartGridToolbox header files.
				</p>
				<p>
					Header files may be included individually, as follows:
<pre><code>#include &ltSmartGridToolbox/Model.h&gt
#include &ltSmartGridToolbox/Simulation.h&gt
// ... 
</code></pre>
					or they may be all included automatically using <pre><code>#include &ltSmartGridToolbox.h&gt</code></pre>
				</p>
				<p>
					When linking, you should include <code>-lSmartGridToolbox</code> in the compiler link flags. (If you use the MicrogridTutorial example as a template, including the autoconf and automake scripts, then this will be done automatically). Your compiler will also need to be able to find the SmartGridToolbox library; you may need to add an extra <code>-L</code> compile flag if you have installed it in a non-standard location.
				</p>
				<h4><a name="sgt-program-structure" class="anchor" href="#sgt-program-structure"></a>Basic structure of a SmartGridToolbox program</h4>
				<p>
					At the top level, a SmartGridToolbox simulation will have two basic objects: a <code>Model</code> object, and a <code>Simulation</code> object. The model manages the elements, or <em>components</em> used in the simulation, and the simulation is responsible for advancing time for all the components of the model.
				</p>
				<p>
					The following simple program can be found in <code>/Users/dgordon/Devel/SmartGridToolbox/docs/tutorials/IntroductionToSgt/src/tickers.cc</code>.
<pre><code>#include &ltSmartGridToolbox.h&gt

int main()
{
   using SmartGridToolbox::Model;
   using SmartGridToolbox::RegularUpdateComponent;
   using seconds = SmartGridToolbox::posix_time::seconds;
   using SmartGridToolbox::Simulation;

   // Create the model:
   Model mod;

   // Now populate the model using factory functionality of Model.
   // The RegularUpdateComponent does nothing other than regularly update itself, every 1 second in this case.
   RegularUpdateComponent & ticker1 = 
      mod.newComponent&ltRegularUpdateComponent&gt("ticker_1");
   ticker1.setDt(seconds(1));
   // And here's one that updates every 2 seconds...
   RegularUpdateComponent & ticker2 = 
      mod.newComponent&ltRegularUpdateComponent&gt("ticker_2");
   ticker2.setDt(seconds(2));

   mod.validate();

   // Set up the simulation.
   Simulation sim(mod);
   sim.setStartTime(seconds(0));
   sim.setEndTime(seconds(5));
   sim.initialize();

   std::cout << "Initial timestep : simulation is at time = " << sim.currentTime() << "." << std::endl;
   std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
   std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
   std::cout << std::endl;
   while (sim.doTimestep())
   {
      std::cout << "New timestep     : simulation is at time = " << sim.currentTime() << "." << std::endl;
      std::cout << "                 : ticker_1 is at time = " << ticker1.time() << "." << std::endl;
      std::cout << "                 : ticker_2 is at time = " << ticker2.time() << "." << std::endl;
      std::cout << std::endl;
   }
}</code></pre>
				</p>
				<p>
					It illustrates both how to set up a simple SmartGridToolbox program, and certain simple aspects of the event based simulation architecture.
				</p>
				<p>
					The output, upon running the program above, is:
					<pre><code>MESSAGE:	Component ticker_1 added to model.
MESSAGE:	Component ticker_2 added to model.
MESSAGE:	Model after validation:
MESSAGE:		ticker_1 0
MESSAGE:		ticker_2 0
Initial timestep : simulation is at time = 00:00:00.
                 : ticker_1 is at time = 00:00:00.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:01.
                 : ticker_1 is at time = 00:00:01.
                 : ticker_2 is at time = 00:00:00.

New timestep     : simulation is at time = 00:00:02.
                 : ticker_1 is at time = 00:00:02.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:03.
                 : ticker_1 is at time = 00:00:03.
                 : ticker_2 is at time = 00:00:02.

New timestep     : simulation is at time = 00:00:04.
                 : ticker_1 is at time = 00:00:04.
                 : ticker_2 is at time = 00:00:04.</code></pre>
				</p>
				<p>
					Note that at each timestep, more than one component update may occur. To get finer control over the updates, we can change the final <code>while</code> loop so that looping occurs at every single component update, but changing <code>while (sim.doTimestep())</code> to <code>while (sim.doNextUpdate())</code> <strong>Exercise: copy the tutorial directory and try it</strong>. 
				<p> 
					Also note that when the simulation is at a given time, there may be components that have not yet updated to that time. This will be the case when they have not required a <em>scheduled update</em> at that time, and no other component has requested that they require a <em>contingent update</em> - but more about this later.
				</p>
				<p>
					In the example above, we added components to the simulation programmatically. In most SmartGridToolbox programs, the components will instead be parsed in from a YAML configuration file.
				</p>
			</section>
		</div>
	</body>
</html>
